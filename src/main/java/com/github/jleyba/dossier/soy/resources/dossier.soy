{namespace dossier.soy autoescape="deprecated-noncontextual"}

/**
 * The main page header; responsible for setting the doctype, title, and
 * linking in any necessary stylesheets.
 */
{template .pageHeader}
  {@param title: string}
  {@param resources: dossier.Resources}

  <!DOCTYPE html>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Language" content="en" />
  <title>{$title}</title>
  {foreach $script in $resources.headScript}
    <script src="{$script}"></script>
  {/foreach}
  {foreach $styleSheet in $resources.css}
    <link href="{$styleSheet}" rel="stylesheet" type="text/css">
  {/foreach}
  <header>
    <div>
      <form>
        <div>
          <input type="search" placeholder="Search">
        </div>
      </form>
    </div>
  </header>
{/template}


/**
 * Generates the nav list.
 */
{template .sideNav}
  {@param index: dossier.Index}

  <nav>
    <h3><a href="{$index.home}">Overview</a></h3>
    {if length($index.module)}
      <div>
        <input type="checkbox" id="nav-modules" checked/>
        <label for="nav-modules"><h3>Modules</h3></label>
        <div>
          <ul>
            {foreach $module in $index.module}
              <li><a href="{$module.link.href}">{$module.link.text}</a>
            {/foreach}
          </ul>
        </div>
      </div>
    {/if}
    {if length($index.type)}
      <div>
        <input type="checkbox" id="nav-types" checked/>
        <label for="nav-types"><h3>Types</h3></label>
        <div>
          <ul>
            {foreach $link in $index.type}
              <li><a href="{$link.href}">{$link.text}</a>
            {/foreach}
          </ul>
        </div>
      </div>
    {/if}
  </nav>
{/template}


/**
 * Generates the page footer.
 */
{template .footer private="true"}
  {@param resources: dossier.Resources}

  /* used for vertical fill from main. */
  <div class="pre-footer"><div></div></div>

  <footer>
    <a href="https://github.com/jleyba/js-dossier">Generated by dossier</a>
  </footer>
  {foreach $script in $resources.tailScript}
    <script src="{$script}"></script>
  {/foreach}
{/template}


/**
 * Renders a block comment.
 */
{template .comment}
  {@param comment: dossier.Comment}
  {@param? omitLeadingTag: bool}  /* Whether to omit the leading P tag. */

  {if $comment and length($comment.token)}
    {if not $omitLeadingTag}<p>{/if}
    {foreach $token in $comment.token}
      {if $token.isCode}<code>{/if}
      {if $token.href}
        <a href="{$token.href}">
      {elseif $token.unresolvedLink}
        <a class="unresolved-link">
      {/if}
      {if $token.isCode or $token.isLiteral}
        {$token.text}
      {else}
        {$token.text |noAutoescape}
      {/if}
      {if $token.unresolvedLink or $token.href}</a>{/if}
      {if $token.isCode}</code>{/if}
    {/foreach}
  {/if}
{/template}


/**
 * Renders a source link.
 */
{template .sourceLink private="true"}
  {@param text: string}                // The link text.
  {@param source: dossier.SourceLink}  // The link.
  {if $source.path}
    <a href="{$source.path}{if $source.line and $source.line > 0}#l{$source.line}{/if}">{$text}</a>
  {else}
    {$text}
  {/if}
{/template}

/**
 * Prints a graphical representation of a class's type inheritance:
 * goog.Foo
 *   - goog.Bar
 *       - goog.Bim
 *           - goog.Baz
 *
 * This template is a no-op if given a non-class descriptor.
 */
{template .classInheritance}
  {@param types: list<dossier.Comment>}

  {if length($types) >= 2}
    <pre class="inheritance">
      {foreach $type in $types}
        {if not isFirst($type)}
          {\n}{print '  '}
          {if index($type) > 1}
            {for $i in range(index($type) - 1)}{print '    '}{/for}
          {/if}
          &#x2514;{sp}
        {/if}
        {call .comment}
          {param comment: $type /}
          {param omitLeadingTag: true /}
        {/call}
      {/foreach}
    </pre>
  {/if}
{/template}


/**
 * Prints information about the interfaces the given descriptor implements or
 * extends (if itself an interface).
 */
{template .printInterfaces private="true"}
  {@param type: dossier.JsType}

  // Note: if type is itself an interface, it will not be included in the
  // |implemented_type| list.
  {if length($type.implementedType)}
    <dt>
      All {if $type.tags.isInterface}extended{else}implemented{/if} interfaces:
    <dd>
      {foreach $interface in $type.implementedType}
        <code>
          {call .comment}
            {param comment: $interface /}
            {param omitLeadingTag: true /}
          {/call}
        </code>
        {if not isLast($interface)},{sp}{/if}
      {/foreach}
  {/if}
{/template}


/**
 * Prints a link to another descriptor that the given type is an alias
 * for.
 */
{template .printAliasLink private="true"}
  {@param type: dossier.JsType}

  {if $type.aliasedType}
    <dt>Alias for{sp}
      <code>
        {if $type.aliasedType.href}
          <a href="{$type.aliasedType.href}">{$type.aliasedType.text}</a>
        {else}
          {$type.aliasedType.text}
        {/if}
      </code>
  {/if}
{/template}


/**
 * Prints a notification that a descriptor is deprecated.
 */
{template .deprecationNotice private="true"}
  {@param deprecation: dossier.Deprecation}
  {@param? omitLeadingTag: bool}

  {if $deprecation and $deprecation.notice and length($deprecation.notice.token)}
    {if not $omitLeadingTag}<p>{/if}
      <b>Deprecated: </b>
      {call .comment}
        {param comment: $deprecation.notice /}
        {param omitLeadingTag: true /}
      {/call}
    {if not $omitLeadingTag}</p>{/if}
  {/if}
{/template}


/**
 * Prints the values for the given enumeration.
 */
{template .enumValues private="true"}
  {@param enumeration: dossier.Enumeration}

  {if length($enumeration.value)}
    <h2>Values and Descriptions</h2>
    <dl>
      {foreach $value in $enumeration.value}
        <dt{if $value.deprecation.notice and length($value.deprecation.notice.token)} class="deprecated"{/if}>
          <a id="{$value.name}"></a>
          {$value.name}
        {if ($value.description and length($value.description.token)) or
            ($value.deprecation
             and $value.deprecation.notice
             and length($value.deprecation.notice.token))}
          <dd>
            {call .comment}
              {param comment: $value.description /}
              {param omitLeadingTag: true /}
            {/call}
            {if $value.deprecation.notice and length($value.deprecation.notice.token)}
              {if ($value.description and length($value.description.token))}<br>{/if}
              {call .deprecationNotice}
                {param deprecation: $value.deprecation /}
                {param omitLeadingTag: true /}
              {/call}
            {/if}
        {/if}
      {/foreach}
    </dl>
  {/if}
{/template}


/**
 * Prints the summaries for the types nested within this type (e.g. classes,
 * enums, and interfaces).
 *
 * @param title The section title.
 * @param types A list of Dossier.JsType.NestedTypes.TypeSummary objects.
 */
{template .nestedTypeSummaries}
  {if length($types) > 0}
    <section>
      <h2>{$title}</h2>
      <div class="type-summary">
        <table><tbody><tr><td><dl>
          {foreach $type in $types}
            <dt><a href="{$type.href}">{$type.name}</a>
            <dd>
              {if $type.summary and length($type.summary.token)}
                {call .comment}
                  {param comment: $type.summary /}
                  {param omitLeadingTag: true /}
                {/call}
              {else}
                No Description.
              {/if}
          {/foreach}
        </dl></table>
      </div>
    </section>
  {/if}
{/template}


/**
 * Generates the table rows for describing a function's return value. Will
 * only generate content if there is a return description, or a non-vacuous
 * return type expression (i.e. nothing will be generated if the only
 * return detail is the type is "*", "undefined", etc.)
 */
{template .returnDetails}
  {@param details: dossier.Function.Detail}

  /*
   * Pre-render the return type and comment. If non-empty, these will be
   * rendered into this template using |noAutoescape - which is safe
   * since the content will already be sanitized by the .comment template.
   */

  {let $returnType}
    {if $details}
      {call .comment}
        {param comment: $details.type /}
        {param omitLeadingTag: true /}
      {/call}
    {/if}
  {/let}

  {let $returnComment}
    {if $details}
      {call .comment}
        {param comment: $details.description /}
        {param omitLeadingTag: true /}
      {/call}
    {/if}
  {/let}

  /*
   * In Closure code developers will often omit an actual comment
   * while still satisfying the linter by writing:
   *     @return {string} .
   *
   * We ignore these comments.
   */
  {let $hasComment: $returnComment and $returnComment != '.' /}

  {if $returnType or $hasComment}
    <tr><th>Returns</th>
    <tr><td>
      {if $returnType}
        <dl>
          <dt>
            <code>{$returnType |noAutoescape}</code>
            {if $hasComment}
              <dd>{$returnComment |noAutoescape}
            {/if}
        </dl>
      {elseif $hasComment}
        <p>{$returnComment |noAutoescape}</p>
      {/if}
  {/if}
{/template}


/**
 * Generates the table rows that describe some typed details about a function,
 * such as the named parameters or the conditions under which the function will
 * throw.
 */
{template .typeDetails}
  {@param header: string}
  {@param details: list<dossier.Function.Detail>}

  {if $details and length($details) > 0}
    <tr><th>{$header}
    <tr><td><dl>
      {foreach $detail in $details}
        <dt>
        {if $detail.name}{$detail.name}{/if}
        {if $detail.type and length($detail.type.token)}
          <code>
            {call .comment}
              {param comment: $detail.type /}
              {param omitLeadingTag: true /}
            {/call}
          </code>
        {/if}

        {let $detailComment}
          {if $detail.description}
            {call .comment}
              {param comment: $detail.description /}
              {param omitLeadingTag: true /}
            {/call}
          {/if}
        {/let}
        {if $detailComment and $detailComment != '.'}
          <dd>{$detailComment |noAutoescape}  /* Already escaped by .comment template */
        {/if}
      {/foreach}
    </dl>
  {/if}
{/template}


/**
 * Generates a table with details about a single function, such as its
 * arguments, thrown types, deprecation notice, and return type.
 */
{template .fnDetails}
  {@param fn: dossier.Function}
  // Only generate the table if there is data to actually display.
  {if length($fn.parameter)
      or length($fn.thrown)
      or ($fn.return and not $fn.isConstructor
          and (($fn.return.description and length($fn.return.description.token))
          or ($fn.return.type and length($fn.return.type.token))))}
    <div>
      <table><tbody>
        {call .typeDetails}
          {param header: 'Parameters' /}
          {param details: $fn.parameter /}
        {/call}
        {if not $fn.isConstructor}
          {call .returnDetails}
            {param details: $fn.return /}
          {/call}
        {/if}
        {call .typeDetails}
          {param header: 'Throws' /}
          {param details: $fn.thrown /}
        {/call}
      </table>
    </div>
  {/if}
{/template}


/**
 * Prints a list of template type names: {@literal <A, B, C>}.
 *
 * @param names The list of template type names.
 */
{template .printTemplateNames}
  &lt;
  {foreach $name in $names}
    {$name}
    {if not isLast($name)},{sp}{/if}
  {/foreach}
  &gt;
{/template}


/** Renders a list of function arguments. */
{template .functionArgs}
  {@param fn: dossier.Function}
  (
  {foreach $parameter in $fn.parameter}
    {$parameter.name}
    {if not isLast($parameter)},{sp}{/if}
  {/foreach}
  )
{/template}


/**
 * Generates the HTML for a type descriptor's main function (which is either
 * a constructor or the primary function in a namespace/module which all other
 * properties are hung off of).
 */
{template .mainFunction}
  {@param type: dossier.JsType}

  {let $fn: $type.mainFunction /}
  {let $isNonTrivial: length($fn.parameter)
                      or length($fn.thrown)
                      or ($fn.return
                          and $fn.return.description
                          and length($fn.return.description.token)
                          and not $fn.isConstructor) /}
  {if $isNonTrivial}
    <h2 class="main">
      {if $fn.isConstructor}new{sp}{/if}
      {$type.name}
      {call .functionArgs}
        {param fn: $fn /}
      {/call}
    </h2>
    {call .fnDetails}
      {param fn: $fn /}
    {/call}
  {/if}
{/template}


/**
 * Generates the HTML for documenting a function property.
 */
{template .printFunction}
  {@param  fn: dossier.Function}

  <h3>
    {if $fn.templateName and length($fn.templateName)}
      <code>
        {call .printTemplateNames}
          {param names: $fn.templateName /}
        {/call}
      </code>
      {sp}
    {/if}

    /* TODO: deprecation $fn.base.deprecation */
    <a id="{$fn.base.name}"></a>
    {$fn.base.name}
    (
    {foreach $parameter in $fn.parameter}
      {$parameter.name}
      {if not isLast($parameter)},{sp}{/if}
    {/foreach}
    )
    {if $fn.base.source.path}
      <span class="codelink">
        {call .sourceLink}
          {param text: 'code »' /}
          {param source: $fn.base.source /}
        {/call}
      </span>
    {/if}
  </h3>
  {call .tags}
    {param tags: $fn.base.tags /}
  {/call}

  {if ($fn.base.description and length($fn.base.description.token))
      or $fn.base.overrides
      or length($fn.base.specifiedBy)
      or length($fn.parameter)
      or length($fn.thrown)
      or ($fn.return and
          (($fn.return.description and length($fn.return.description.token)) or
           ($fn.return.type and length($fn.return.type.token))))}
    {call .comment}
      {param comment: $fn.base.description /}
    {/call}
    {call .fnOverrides}
      {param fn: $fn /}
    {/call}
    {call .deprecationNotice}
      {param deprecation: $fn.base.deprecation /}
    {/call}
    {call .fnDetails}
      {param fn: $fn /}
    {/call}
  {elseif $fn.base.deprecation
      and $fn.base.deprecation.notice
      and length($fn.base.deprecation.notice.token)}
    {call .deprecationNotice}
      {param deprecation: $fn.base.deprecation /}
    {/call}
  {else}
    <p>No information.</p>
  {/if}
{/template}


/**
 * Template for rendering type information about what a function overrides
 * or any interfaces it is specified by.
 */
{template .fnOverrides}
  {@param fn: dossier.Function}
  {let $base: $fn.base /}

  {if $base.definedBy or length($base.specifiedBy) or $base.overrides}
    <p>
      {if $base.definedBy}
        <b>Defined by: </b>
        {call .comment}
          {param comment: $base.definedBy /}
          {param omitLeadingTag: true /}
        {/call}
        {if $base.overrides or length($base.specifiedBy)}<br>{/if}
      {/if}
      {if $base.overrides}
        <b>Overrides: </b>
        {call .comment}
          {param comment: $base.overrides /}
          {param omitLeadingTag: true /}
        {/call}
        {if length($base.specifiedBy)}<br>{/if}
      {/if}
      {if length($base.specifiedBy)}
        <b>Specified by: </b>
        {foreach $spec in $base.specifiedBy}
          {call .comment}
            {param comment: $spec /}
            {param omitLeadingTag: true /}
          {/call}
          {if not isLast($spec)}
            ,{sp}
          {/if}
        {/foreach}
      {/if}
    </p>
  {/if}

{/template}


/**
 * Generates the HTML for documenting an object property.
 */
{template .printProperty}
  {@param prop: dossier.Property}

  <dt>
    <a id="{$prop.base.name}"></a>
    {call .sourceLink}
      {param text: $prop.base.name /}
      {param source: $prop.base.source /}
    {/call}
    /* todo: deprecation */
    {if $prop.type}
      <code>
        {call .comment}
          {param comment: $prop.type /}
          {param omitLeadingTag: true /}
        {/call}
      </code>
    {/if}
  <dd>
    {if $prop.base.description and length($prop.base.description.token)}
      {call .comment}
        {param comment: $prop.base.description /}
        {param omitLeadingTag: true /}
      {/call}
    {else}
      No description.
    {/if}
{/template}


/**
 * Print a list of functions.
 */
{template .printFunctions}
  {@param functions: list<dossier.Function>}
  {@param? parentName: string}

  {foreach $fn in $functions}
    {call .printFunction}
      {param fn: $fn /}
      {param parentName: $parentName /}
    {/call}
    {if not isLast($fn)}<hr class="fn-sep">{/if}
  {/foreach}
{/template}

/**
 * Print a list of properties.
 */
{template .printProperties}
  {@param properties: list<dossier.Property>}
  {@param? parentName: string}

  {foreach $property in $properties}
    {call .printProperty}
      {param prop: $property /}
      {param parentName: $parentName /}
    {/call}
  {/foreach}
{/template}


/**
 * Renders documentation for properties defined on the given type's
 * prototype chain.
 */
{template .prototype}
  {@param type: dossier.JsType}

  {if length($type.method)}
    <h2>Instance Methods</h2>
    {call .printFunctions}
      {param functions: $type.method /}
    {/call}
  {/if}

  {if length($type.field)}
    <h2>Instance Properties</h2>
    <dl>
      {foreach $property in $type.field}
        {call .printProperty}
          {param prop: $property /}
        {/call}
      {/foreach}
    </dl>
  {/if}
{/template}


/**
 * Prints the static property information for the given descriptor.
 */
{template .static}
  {@param type: dossier.JsType}

  {if length($type.staticFunction)}
    <h2>
      {if $type.mainFunction and $type.mainFunction.isConstructor}
        Static Functions
      {else}
        Functions
      {/if}
    </h2>
    {call .printFunctions}
      {param functions: $type.staticFunction /}
    {/call}
  {/if}

  {if length($type.staticProperty)}
    <h2>
      {if $type.mainFunction and $type.mainFunction.isConstructor}
        Static Properties
      {else}
        Properties
      {/if}
    </h2>
    <dl>
      {call .printProperties}
        {param properties: $type.staticProperty /}
      {/call}
    </dl>
  {/if}

  {if length($type.compilerConstant)}
    <h2>Compiler Constants</h2>
    <dl>
      {call .printProperties}
        {param properties: $type.compilerConstant /}
      {/call}
    </dl>
  {/if}
{/template}


/**
 * Generates the header for the main section of a type file.
 */
{template .typeHeader}
  {@param type: dossier.JsType}

  {if $type.parent}
    <div class="parentlink">
      <b>{if $type.parent.isModule}Module{else}Namespace{/if}:</b>{sp}
      {if $type.parent.link.href}
        <a href="{$type.parent.link.href}">{$type.parent.link.text}</a>
      {else}
        {$type.parent.link.text}
      {/if}
    </div>
  {/if}
  {if $type.source}
    <div class="codelink">
      {call .sourceLink}
        {param text: 'View Source' /}
        {param source: $type.source /}
      {/call}
    </div>
  {/if}
  <h1{if $type.deprecation} class="deprecated"{/if}>
    {if $type.tags.isModule}
      module {$type.name}
    {elseif $type.tags.isInterface}
      interface {$type.name}
    {elseif $type.mainFunction and $type.mainFunction.isConstructor}
      class {$type.name}
    {elseif $type.enumeration}
      enum {$type.name}
    {else}
      namespace {$type.name}
    {/if}
    {if $type.mainFunction and length($type.mainFunction.templateName)}
      {call .printTemplateNames}
        {param names: $type.mainFunction.templateName /}
      {/call}
    {/if}
  </h1>
  {call .tags}
    {param tags: $type.tags /}
  {/call}

  {call .classInheritance}
    {param types: $type.extendedType /}
  {/call}
  {if $type.aliasedType
      or length($type.implementedType)
      or ($type.enumeration and length($type.enumeration.type.token))}
    <dl>
      {if $type.enumeration and length($type.enumeration.type.token)}
        <dt>Type
          <code>
            {call .comment}
              {param comment: $type.enumeration.type /}
              {param omitLeadingTag: true /}
            {/call}
          </code>
      {/if}
      {call .printAliasLink}
        {param type: $type /}
      {/call}
      {call .printInterfaces}
        {param type: $type /}
      {/call}
    </dl>
  {/if}
  {call .deprecationNotice}
    {param deprecation: $type.deprecation /}
  {/call}
{/template}


/**
 * Renders a list of tags.
 */
{template .tags private="true"}
  {@param tags: dossier.Tags}
  {@param? span: bool}
  {if $tags.isDeprecated
      or $tags.isConst
      or $tags.isFinal
      or $tags.isDict
      or $tags.isStruct}
    <{if $span}span{else}div{/if} class="tags">
      {if $tags.isDeprecated}<span>deprecated</span>{/if}
      {if $tags.isConst}<span>const</span>{/if}
      {if $tags.isFinal}<span>final</span>{/if}
      {if $tags.isDict}<span>dict</span>{/if}
      {if $tags.isStruct}<span>struct</span>{/if}
    </{if $span}span{else}div{/if}>
  {/if}
{/template}


/**
 * Generates an HTML page for displaying the documentation about a single
 * JavaScript type or namespace.
 */
{template .typefile}
  {@param spec: dossier.JsTypeRenderSpec}

  {call .pageHeader}
    {param title: $spec.type.name /}
    {param resources: $spec.resources /}
  {/call}

  <main>
    <article>
      {call .typeHeader}
        {param type: $spec.type /}
      {/call}
      {call .comment}
        {param comment: $spec.type.description /}
      {/call}

      {if not $spec.type.tags.isInterface and $spec.type.mainFunction}
        {call .mainFunction}
          {param type: $spec.type /}
        {/call}
      {/if}

      {if $spec.type.enumeration}
        {call .enumValues}
          {param enumeration: $spec.type.enumeration /}
        {/call}
      {/if}

      {call .prototype}
        {param type: $spec.type /}
      {/call}

      {call .static}
        {param type: $spec.type /}
      {/call}

      /* TODO: merged nested types into a flat list, not sorted by category */
      {if length($spec.type.nested) > 0}
        <h2>Types</h2>
        <dl>
          {foreach $type in $spec.type.nested}
            <dt><a href="{$type.href}">{$type.name}</a>
            <dd>
              {if $type.summary and length($type.summary.token)}
                {call .comment}
                  {param comment: $type.summary /}
                  {param omitLeadingTag: true /}
                {/call}
              {else}
                No Description.
              {/if}
          {/foreach}
        </dl>
      {/if}

      {if length($spec.type.typeDef) > 0}
        <h2>Type Definitions</h2>
        <dl>
          {foreach $typedef in $spec.type.typeDef}
            <dt>
              <a id="{$typedef.name}"></a>
              {call .sourceLink}
                {param text: $typedef.name /}
                {param source: $typedef.source /}
              {/call}
              <code>
                {call .comment}
                  {param comment: $typedef.type /}
                  {param omitLeadingTag: true /}
                {/call}
              </code>
            <dd>
              {if $typedef.description and length($typedef.description.token)}
                {call .comment}
                  {param comment: $typedef.description /}
                  {param omitLeadingTag: true /}
                {/call}
              {else}
                No description.
              {/if}
            /* TODO: deprecation notice $typedef.deprecation*/
          {/foreach}
        </dl>
      {/if}

    </article>
    {call .sideNav}
      {param index: $spec.index /}
    {/call}
  </main>
  {call .footer}
    {param resources: $spec.resources /}
  {/call}
{/template}


/**
 * Generates the main index.
 */
{template .indexFile}
  {@param spec: dossier.IndexFileRenderSpec}

  {call .pageHeader}
    /* TODO(jleyba): title should be configurable. */
    {param title: 'Index' /}
    {param resources: $spec.resources /}
  {/call}

  <main>
    <article class="indexfile">
      {if $spec.readme and length($spec.readme.token)}
        {call .comment}
          {param comment: $spec.readme /}
          {param omitLeadingTag: true /}
        {/call}
       {else}
        <strong>TODO</strong>
       {/if}
    </article>
    {call .sideNav}
      {param index: $spec.index /}
    {/call}
  </main>

  {call .footer}
    {param resources: $spec.resources /}
  {/call}
{/template}


/**
 * Generates an HTML page for displaying the contents of a JavaScript source
 * file.
 */
{template .srcfile}
  {@param spec: dossier.SourceFileRenderSpec}

  {call .pageHeader}
    {param title: $spec.file.baseName /}
    {param resources: $spec.resources /}
  {/call}

  <main>
    <article class="srcfile">
    <h1>{$spec.file.path}</h1>

    <table>
      {let $count: 1 /}
      {foreach $line in $spec.file.lines}
        <tr>
          <td>
            <pre><a id="l{$count}"></a><a href="#l{$count}">{$count}</a></pre>
          <td>
            <pre>{$line}</pre>
        {let $count: $count + 1 /}
      {/foreach}
    </table>

    </article>
    {call .sideNav}
      {param index: $spec.index /}
    {/call}
  </main>

  {call .footer}
    {param resources: $spec.resources /}
  {/call}
{/template}